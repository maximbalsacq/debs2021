#![deny(missing_docs)]
//! This crate contains code to solve the DEBS 2021 Grand Challenge

/// Code generated by tonic_build
/// from proto/challenger.proto
pub mod gen;
/// Contains functions to load/store
/// data from/to files.
pub mod io;
/// Contains functions to calculate
/// the air quality index based on p1/p2 values.
pub mod aqi;
/// Provides types to simplify and enhance performance
/// of aggregation of data.
pub mod aggregate;
/// Provides functions to make it possible to split a pair of iterators
/// into two separate iterators and rejoin them. 
/// This provides an alternative to Iterator::zip/Iterator::unzip which
/// require containers to be allocated.
pub mod spliter;
/// Joins all components to solve query 1 of the DEBS Grand Challenge.
pub mod pipeline;

use crate::gen::challenger::Locations;
use geo::{MultiPolygon,point,prelude::{Contains,BoundingRect}};

/// A newtype uniquely identifying a zipcode in AnalysisLocations.
type CityId = u32;

/// A tuple denoting metadata about a Location
#[derive(Debug, PartialEq, Eq)]
pub struct AnalysisLocation {
    /// The locations zipcode
    zipcode: String,
    /// The internal id of the location,
    /// which can be used with AnalysisLocations::lookup
    /// to obtain the location's name
    cityid: CityId,
}


use std::sync::atomic::AtomicUsize;

/// A collection of Locations which can be queried using latitude and longitude.
#[derive(Debug)]
pub struct AnalysisLocations {
    /// A RTree of the bounding boxes of each zipcode
    /// Used to quickly find zipcodes which could contain a city.
    bboxtree: RTree<RTreeLocation>,
    /// Stores the polygon(s) for each zipcode.
    /// As bounds testing is slow, insidecache and outsidecache
    /// are checked first.
    locations: Vec<(AnalysisLocation, MultiPolygon<f64>)>,
    /// Is used to check if a point is known to be inside a specific zipcode.
    /// If unknown, the exact (multi)polygon (stored in locations) needs to be queried.
    insidecache: Vec<LocationCache>,
    /// Is used to check if a point is known to be outside a specific zipcode.
    /// If unknown, the exact (multi)polygon (stored in locations) needs to be queried.
    outsidecache: Vec<LocationCache>,
    /// a map from CityId to city name, where CityId is simply an index
    /// into the array
    known_cities: Vec<String>,
    /// Count of how often insidecache was useful
    pub cachehits: AtomicUsize,
    /// Count of how often neither caches was useful
    pub cachemisses: AtomicUsize,
    /// Count of how often outsidecache was useful
    pub outsidecachehits: AtomicUsize,
}

use rstar::{AABB,RTree,RTreeObject,Point,PointDistance};

#[derive(Debug)]
struct RTreeLocation {
    bbox: AABB<[f64; 2]>,   
    /// index into locations array
    idx: u32,
}

impl RTreeObject for RTreeLocation {
    type Envelope = AABB<[f64; 2]>;

    fn envelope(&self) -> Self::Envelope {
        self.bbox.clone()
    }
}

impl PointDistance for RTreeLocation {
    fn distance_2(
        &self,
        point: &[f64; 2],
    ) -> <[f64;2] as Point>::Scalar {
        self.bbox.distance_2(point)
    }
}

/// A list of LocationCacheItem(s) is used to determine
/// if a point is inside/outside a polygon.
/// Each LocationCacheItem represents a circle,
/// positioned at a known point inside/outside the polygon,
/// with the radius extending exactly to the nearest line of
/// the polygon. Any point with a distance smaller than the radius
/// is therefore on the same side as the LocationCacheItem.
#[derive(Debug,Default)]
struct LocationCacheItem {
    /// The x coordinate (longitude) of the center of the circle.
    x: f32,
    /// The y coordinate (latitude) of the center of the circle.
    y: f32,
    /// The squared radius of the circle. This is equal to the squared
    /// distance to the closest line. As comparing distances between points
    /// does not require calculating the actual value of the distance,
    /// storing the squared value makes it possible to skip the calculation.
    rsquare: f32,
}

use std::sync::RwLock;

/// Amount of items in a LocationCache.
/// Raising this number increases the hit rate of the cache,
/// but also increases the nubmer of items which need to be checked.
const CACHE_SIZE: usize = 32;

use arrayvec::ArrayVec;
use rstar::primitives::Line;

/// LocationCache is used to quickly determine if a point is
/// known to be inside/outside of a polygon.
/// See [LocationCacheItem] for details.
/// All added points need to be on the same side of the polygon,
/// adding a point from the opposite side is a logic error and
/// may result in contains returning false positives.
#[derive(Debug,Default)]
struct LocationCache {
    /// When adding an item, this is used to find the closest line
    /// to the point which is being added.
    lines: RTree<Line<[f32; 2]>>,
    // items: RwLock<RTree<LocationCacheItem, LocationRTreeParams>>,
    /// A list of CACHE_SIZE LocationCacheItem,
    /// protected from concurrent access using RwLock
    items: RwLock<ArrayVec<LocationCacheItem, CACHE_SIZE>>,
}

impl LocationCache {
    /// Creates a new LocationCache for the given location
    fn new(locations: &crate::gen::challenger::Location) -> Self {
        let points = locations.polygons
            .iter()
            .flat_map(|poly| poly.points.iter())
            .map(|point| [point.longitude as f32, point.latitude as f32])
            .collect::<Vec<_>>();
        let points_len = points.len();
        assert!(points_len > 0);
        let lines = (0..points_len)
            .map(|idx| {
                let first_point = points[idx];
                let second_point = if idx != points_len - 1 {
                    points[idx+1]
                } else {
                    points[0] // last point connects to first
                };
                rstar::primitives::Line::new(first_point, second_point)
            })
            .collect::<Vec<_>>();
        let lines = RTree::bulk_load(lines);
        LocationCache {
            lines,
            // items: RwLock::new(RTree::new_with_params()),
            // items: RwLock::new(Vec::with_capacity(<LocationRTreeParams as rstar::RTreeParams>::MAX_SIZE)),
            items: RwLock::new(ArrayVec::new()),
        }
    }

    /// Checks if the LocationCache contains a point at a given latitude and longitude.
    /// If the LocationCache contains this value (=> this function returns true),
    /// the location (inside/outside) of the point is
    /// the same as the one for the LocationCache.
    /// Note that the inverse is not necessarily true: If this function returns false,
    /// the point may still be on the same side as this LocationCache.
    /// This will occur quite often due to cache misses.
    /// In such cases a check with the actual polygon is necessary.
    fn contains(&self, latitude: f32, longitude: f32) -> bool {
        self.items
            .read()
            .unwrap()
            .iter()
            .map(|item| (item, [item.x, item.y].distance_2(&[longitude, latitude])))
            .any(|(item, distance)| distance < item.rsquare)
    }

    /// Adds a point at the given coordinates to this LocationCache.
    fn add(&self, latitude: f32, longitude: f32) {
        if self.items.read().unwrap().len() >= CACHE_SIZE {
            return;
        }

        let rsquare = self.lines.nearest_neighbor_iter_with_distance_2(&[longitude, latitude])
            .map(|(_line, distance)| distance)
            .next()
            .expect("Should have at least two points");
        if rsquare < 0.00001 {
            // don't keep items very close to the border
            return;
        }
        
        let mut items = self.items.write().unwrap();
        if items.len() >= CACHE_SIZE {
            // can happen since read lock was dropped previously
            // just abort
            return;
        }
        items.push(LocationCacheItem {
            x: longitude,
            y: latitude,
            rsquare,
        });
    }
}

impl AnalysisLocations {
    /// Creates a new AnalysisLocations struct using
    /// the Locations deserialized from protobuf.
    pub fn new(locations: Locations) -> Self {
        use std::iter::FromIterator;
        use std::collections::BTreeMap;
        let mut known_cities_map = BTreeMap::new();
        let mut known_cities = vec![];
        let mut next_id = 0u32;
        let cache : Vec<LocationCache> = locations.locations.iter()
            .map(|location| LocationCache::new(location))
            .collect();
        let outsidecache : Vec<LocationCache> = locations.locations.iter()
            .map(|location| LocationCache::new(location))
            .collect();
        let locations : Vec<(AnalysisLocation, MultiPolygon<f64>)> = locations.locations.into_iter()
            .map(|location| {
                let multipoly = geo::MultiPolygon::from_iter(
                    location
                        .polygons
                        .iter()
                        .map(|poly| geo::Polygon::new(
                            // exterior ring
                            geo::LineString::from_iter(
                                poly.points
                                .iter()
                                .map(|point| (point.longitude, point.latitude))),
                            // interior ring (unused)
                            vec![]
                        ))
                );
                let cityid = match known_cities_map.get(&location.city) {
                    Some(id) => *id,
                    None => {
                        known_cities_map.insert(location.city.clone(), next_id);
                        known_cities.push(location.city);
                        next_id += 1;
                        next_id - 1
                    }
                };
                let location = AnalysisLocation {
                    zipcode: location.zipcode,
                    cityid,
                };
                (location, multipoly)
            })
            .collect();
        let bboxitems = locations
            .iter()
            .enumerate()
            .map(|(idx, (_, multipoly))| {
                let boundingrect = multipoly.bounding_rect().expect("Location should contain >= 1 polygon");
                let (minx, miny) = boundingrect.min().x_y();
                let (maxx, maxy) = boundingrect.max().x_y();
                let bbox = AABB::from_corners([minx, miny], [maxx, maxy]);
                RTreeLocation {
                    bbox,
                    idx: idx as u32,
                }
            })
            .collect::<Vec<_>>();
        let bboxtree = RTree::bulk_load(bboxitems);
        Self {
            bboxtree,
            locations,
            known_cities,
            insidecache: cache,
            outsidecache: outsidecache,
            cachehits: AtomicUsize::from(0),
            cachemisses: AtomicUsize::from(0),
            outsidecachehits: AtomicUsize::from(0),
        }
    }

    /// Tries to find the [AnalysisLocation] which contains the given coordinates.
    /// Returns an iterator - in practice it is likely at most one result will be found.
    pub fn localize(&self, latitude: f32, longitude: f32) -> impl Iterator<Item=&AnalysisLocation> {
        self.bboxtree
            .locate_all_at_point(&[longitude as f64, latitude as f64])
            .filter_map(move |treeobject| {
                /* 
                // same code w/o cache. uncomment if you want to compare
                let (location, bounding_poly) = &self.locations[treeobject.idx as usize];
                let p = point!(x: f64::from(longitude), y: f64::from(latitude));
                if bounding_poly.contains(&p) {
                    Some(location)
                } else {
                    None
                }
                */
                if self.outsidecache[treeobject.idx as usize].contains(latitude, longitude) {
                    debug_assert!({
                        let (_, bounding_poly) = &self.locations[treeobject.idx as usize];
                        let p = point!(x: f64::from(longitude), y: f64::from(latitude));
                        !bounding_poly.contains(&p)
                    });
                    self.outsidecachehits.fetch_add(1, std::sync::atomic::Ordering::AcqRel);
                    None
                } else if self.insidecache[treeobject.idx as usize].contains(latitude, longitude) {
                    debug_assert!({
                        let (_, bounding_poly) = &self.locations[treeobject.idx as usize];
                        let p = point!(x: f64::from(longitude), y: f64::from(latitude));
                        bounding_poly.contains(&p)
                    });
                    self.cachehits.fetch_add(1, std::sync::atomic::Ordering::AcqRel);
                    Some(&self.locations[treeobject.idx as usize].0)
                } else {
                    let (location, bounding_poly) = &self.locations[treeobject.idx as usize];
                    let p = point!(x: f64::from(longitude), y: f64::from(latitude));
                    self.cachemisses.fetch_add(1, std::sync::atomic::Ordering::AcqRel);
                    if bounding_poly.contains(&p) {
                        self.insidecache[treeobject.idx as usize].add(latitude, longitude);
                        Some(location)
                    } else {
                        self.outsidecache[treeobject.idx as usize].add(latitude, longitude);
                        None
                    }
                }
            })
    }

    /// Looks up the name of the city using the provided CityId.
    pub fn lookup(&self, cityid: CityId) -> &str {
        &self.known_cities[cityid as usize]
    }
}

#[cfg(test)]
mod tests {
    #[tokio::test]
    async fn check_locating_works() {
        use super::AnalysisLocations;
        use super::io::load_locations;
        let root = std::env::var("DEBS_DATA_ROOT").expect("DEBS_DATA_ROOT not set!");
        let locations = AnalysisLocations::new(load_locations(&root)
            .await
            .expect("Failed to load locations"));
        let mut outside_germany_iter = locations.localize(46.0, 20.0);
        assert_eq!(outside_germany_iter.next(), None);
        let mut freiburg_iter = locations.localize(47.99422, 7.849722);
        let freiburg = freiburg_iter.next();
        assert!(freiburg.is_some());
        assert_eq!(locations.lookup(freiburg.unwrap().cityid), "Freiburg im Breisgau");
        assert_eq!(freiburg_iter.next(), None);
    }

    #[tokio::test]
    async fn check_locating_samples_works() {
        use super::AnalysisLocations;
        use super::io::{load_locations,load_batch_from};
        let root = std::env::var("DEBS_DATA_ROOT").expect("DEBS_DATA_ROOT not set!");
        let locations = AnalysisLocations::new(load_locations(&root)
            .await
            .expect("Failed to load locations"));
        let batch = load_batch_from(&format!("{}/test_batch.bin", root))
            .await
            .expect("Failed to load batch");
        for measurement in batch.lastyear.iter().chain(batch.current.iter()) {
            if measurement.latitude < 47.40724 || measurement.latitude > 54.9079 || measurement.longitude < 5.98815 || measurement.longitude > 14.98853 {
                // skip measurements outside germany
                continue;
            }
            let mut loc = locations.localize(measurement.latitude, measurement.longitude);
            let matching_loc = loc.next();
            matching_loc.expect(&format!("Did not find a matching location for latitude {}, longitude {}", measurement.latitude, measurement.longitude)); // Fail test if no location found
            assert_eq!(loc.next(), None);
        }
    }
}
